---
published: true

layout: single

title: "[2023-04-19] 4. 유용한 OpenCV 함수 및 기능"

categories: [Devcourse-TIL, CV]

tags: Autonomous_Driving CV

toc: true

toc_label : 목차

toc_sticky: true

author_profile: false

sidebar :
    nav : "docs"
---

####  유용한 OpenCV 함수 및 기능



#### 행렬의 합 구하기

```
Scalar sum(InputArray src);
```

- src : 입력 행렬.  1~4 채널 행렬만 지원
- 반환값 : 행렬 원소들의 합



```
uchar data[] = {1, 2, 3, 4, 5, 6};
Mat mat1(2, 3, CV_8UC1, data); // 

int sum1 = (int)sum(mat1)[0]; //  sum이 double 형태로 반환하니 int형태로 변환해야 함
```



#### 행렬의 평균 구하기

```
Scalar mean(InputArray src, InputArray mask = noArray());
```

- src : 입력 행렬 1~4 채널
- mask : 마스크 영상 / mask 행렬 값이 0이 아닌 부분에서만 src 행렬의 평균값을 계산함
- 반환값 : 행렬의 평균 값



```
Mat img = imread("lenna.bmp", IMREAD_GRAYSCALE); // 그레이스케일이라 1채널 
double mean1 = mean(img)[0]; // val[0] = 124.0, val[1] = 0, va1[2] = 0, val[3] = 0 
```

```
Mat img = imread("lenna.bmp", IMREAD_COLOR); // 그레이스케일이라 1채널 
Scalar m = mean(img); // m 변수에 b g r 성분의 평균값이 다 저장되고 m[0]에는 blue 평균값, m[1]에는 green 평균값, m[2]에는 red 평균값, m[3]에는 기본값인 0이 저장됨
```



#### 행렬의 최댓값/최솟값 구하기

```
void minMaxLoc(InputArray src, double* minVal, double* maxVal = 0, Point* minLoc = 0, Point* maxLoc =0, InputArray mask = noArray());
```

- src : 입력 영상. 단일 채널
- minVal, maxVal : 최솟값/최댓값 변수 포인터 (필요 없으면 NULL 지정)
- minLoc, maxLoc : 최솟값/최댓값 위치 변수 포인터 (필요 없으면 NULL 지정)
- mask : 마스크 영상. mask 행렬 값이 0이 아닌 부분에서만 연산을 수행



```
Mat img = imread("lenna.bmp", IMREAD_GRAYSCALE);

double minv, maxv;
Point minLoc, maxLoc;
minMaxLoc(img, &minv, &maxv, &minLoc, &maxLoc); // minv : 25, maxv : 245, minLoc : [508, 71], maxLoc : [116, 273]
```



#### 영상의 속성 변환

- 행렬의 자료형 변환

```
void Mat::convertTo(OutputArray m, int rtype, double alpha=1, double beta=0) const;
```

- m : 출력 영상(행렬)
- rtype : 원하는 출력 행렬 타입
- alpha : 추가적으로 곱할 값
- beta : 추가적으로 더할 값 

![image](https://user-images.githubusercontent.com/116723552/233404789-1ff40cee-9da0-43fb-8b2e-2830c4c9ef54.png)

```
Mat img = imread("lenna.bmp", IMREAD_GRAYSCALE); // CV_8UC1

Mat fimg;
img.converTo(fimg, CV_32FC1); // Float 형식의 실수 값을 저장할 수 있는 형태로 저장
// 주어진 영상의 픽셀 타입을 Unsigned char을 그대로 사용하는 것이 아닌 실수 값 형태로 변환을 해서 어떤 연산을 수행을 했을 때 소수점 아래가 자동으로 잘려나가지 않게 하여 더 정밀한 연산을 하기 위해 사용함\

Mat dst;
fimg.converTo(dst, CV_8UC1);
// 연산을 다했으면 ~~ 다시 그레이스케일로 지정
```



- 행렬의 정규화(원소 값 범위 정규화)

```
void normalizse(InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0, int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray());
```

- src : 입력 영상(행렬)
- dst : 출력 행렬로 src와 같은 크기
- alpha : 목표 노름(norm) 값,  (NORM_MINMAX인 경우) 최솟값
- beta : (NORM_MINMAX인 경우 최댓값
- norm_type : 정규화 타입으로 NORM_INF, NORM_L1, NORM_L2, NORM_MINMAX 중 하나를 지정
  - NORM_MINMAX를 지정할 경우, 출력 행렬 dst의 최솟값은 alpha, 최댓값은 beta가 되도록 설정함
- dtype : 출력 행렬의 타입
- mask : 마스크 영상



```
Mat src = imread("lenna.bmp", IMREAD_GRAYSCALE);

Mat dst;
normalize(src, dst, 0, 255, NORM_MINMAX); // src인 레나 그레이스케일의 최솟값은 25 최댓값은 245 인데 25 값이 0 에 가까워지는 형태가 되고 245 값이 255에 가까워지는 형태로 전체 픽셀 값을 변화 시켜 dst 값을 만듬
```

<center>
    
</center>

<center><img src="https://user-images.githubusercontent.com/116723552/233412750-5f5bdb33-4f7c-417e-afb1-6908f53a7f0f.png" alt="image" /><img src="https://user-images.githubusercontent.com/116723552/233413937-4967e429-0c85-4cb6-b212-e5e059b5ef93.png" alt="image" /></center>













